// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/aereal/poc-graphql-pqs-server/domain"
	"github.com/aereal/poc-graphql-pqs-server/graph/dto"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Character struct {
		Attack        func(childComplexity int) int
		Defence       func(childComplexity int) int
		Element       func(childComplexity int) int
		ElementEnergy func(childComplexity int) int
		Health        func(childComplexity int) int
		Name          func(childComplexity int) int
		Rarelity      func(childComplexity int) int
		Region        func(childComplexity int) int
		UniqueAbility func(childComplexity int) int
		WeaponKind    func(childComplexity int) int
	}

	CharacterConnection struct {
		Nodes    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor func(childComplexity int) int
		HasNext   func(childComplexity int) int
	}

	Query struct {
		Character  func(childComplexity int, name string) int
		Characters func(childComplexity int, order *dto.CharactersOrder, filter *domain.CharacterFilterCriteria, first uint) int
	}

	UniqueAbility struct {
		Kind  func(childComplexity int) int
		Score func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Character.attack":
		if e.complexity.Character.Attack == nil {
			break
		}

		return e.complexity.Character.Attack(childComplexity), true

	case "Character.defence":
		if e.complexity.Character.Defence == nil {
			break
		}

		return e.complexity.Character.Defence(childComplexity), true

	case "Character.element":
		if e.complexity.Character.Element == nil {
			break
		}

		return e.complexity.Character.Element(childComplexity), true

	case "Character.elementEnergy":
		if e.complexity.Character.ElementEnergy == nil {
			break
		}

		return e.complexity.Character.ElementEnergy(childComplexity), true

	case "Character.health":
		if e.complexity.Character.Health == nil {
			break
		}

		return e.complexity.Character.Health(childComplexity), true

	case "Character.name":
		if e.complexity.Character.Name == nil {
			break
		}

		return e.complexity.Character.Name(childComplexity), true

	case "Character.rarelity":
		if e.complexity.Character.Rarelity == nil {
			break
		}

		return e.complexity.Character.Rarelity(childComplexity), true

	case "Character.region":
		if e.complexity.Character.Region == nil {
			break
		}

		return e.complexity.Character.Region(childComplexity), true

	case "Character.uniqueAbility":
		if e.complexity.Character.UniqueAbility == nil {
			break
		}

		return e.complexity.Character.UniqueAbility(childComplexity), true

	case "Character.weaponKind":
		if e.complexity.Character.WeaponKind == nil {
			break
		}

		return e.complexity.Character.WeaponKind(childComplexity), true

	case "CharacterConnection.nodes":
		if e.complexity.CharacterConnection.Nodes == nil {
			break
		}

		return e.complexity.CharacterConnection.Nodes(childComplexity), true

	case "CharacterConnection.pageInfo":
		if e.complexity.CharacterConnection.PageInfo == nil {
			break
		}

		return e.complexity.CharacterConnection.PageInfo(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNext":
		if e.complexity.PageInfo.HasNext == nil {
			break
		}

		return e.complexity.PageInfo.HasNext(childComplexity), true

	case "Query.character":
		if e.complexity.Query.Character == nil {
			break
		}

		args, err := ec.field_Query_character_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Character(childComplexity, args["name"].(string)), true

	case "Query.characters":
		if e.complexity.Query.Characters == nil {
			break
		}

		args, err := ec.field_Query_characters_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Characters(childComplexity, args["order"].(*dto.CharactersOrder), args["filter"].(*domain.CharacterFilterCriteria), args["first"].(uint)), true

	case "UniqueAbility.kind":
		if e.complexity.UniqueAbility.Kind == nil {
			break
		}

		return e.complexity.UniqueAbility.Kind(childComplexity), true

	case "UniqueAbility.score":
		if e.complexity.UniqueAbility.Score == nil {
			break
		}

		return e.complexity.UniqueAbility.Score(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCharacterFilterCriteria,
		ec.unmarshalInputCharactersOrder,
		ec.unmarshalInputComparisonCriterion,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../etc/core.schema.gql", Input: `scalar UnsignedInt

scalar Numeric

enum Element {
  PYRO
  HYDRO
  CRYO
  ELECTRO
  ANEMO
  GEO
  DENDRO
}

enum WeaponKind {
  SWORD
  CLAYMORE
  BOW
  CATALYST
  POLEARM
}

enum Region {
  MONDSTADT
  LIYUE
  INAZUMA
  SUMERU
  FONTAINE
  NATLAN
  SNEZHNAYA
}

enum OrderDirection {
  ASC
  DESC
}

enum CharacterOrderField {
  HEALTH
  ATTACK
  DEFENCE
  ELEMENT_ENERGY
  UNIQUE_ABILITY_SCORE
}

enum ComparisonOperator {
  EQ
  LT
  LTE
  GT
  GTE
}

type UniqueAbility {
  kind: String!
  score: Float!
}

type Character {
  name: String!
  element: Element!
  weaponKind: WeaponKind!
  region: Region!
  rarelity: Int!
  health: Int!
  attack: Int!
  defence: Int!
  elementEnergy: Int!
  uniqueAbility: UniqueAbility!
}

type CharacterConnection {
  nodes: [Character!]!
  pageInfo: PageInfo!
}

type PageInfo {
  hasNext: Boolean!
  endCursor: String
}

input ComparisonCriterion {
  op: ComparisonOperator!
  value: Numeric!
}

input CharactersOrder {
  field: CharacterOrderField!
  direction: OrderDirection!
}

input CharacterFilterCriteria {
  element: Element
  weaponKind: WeaponKind
  region: Region
  uniqueAbilityKind: String
  rarelity: Int
  health: ComparisonCriterion
  attack: ComparisonCriterion
  defence: ComparisonCriterion
  elementEnergy: ComparisonCriterion
  uniqueAbilityScore: ComparisonCriterion
}

extend type Query {
  character(name: String!): Character
  characters(
    order: CharactersOrder
    filter: CharacterFilterCriteria
    first: UnsignedInt!
  ): CharacterConnection!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
